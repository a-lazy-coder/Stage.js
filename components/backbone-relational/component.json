{
  "name": "backbone-relational",
  "description": "Get and set relations (one-to-one, one-to-many, many-to-one) for Backbone models",
  "keywords": [
    "Backbone",
    "relation",
    "nested",
    "model"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/PaulUithol/Backbone-relational.git"
  },
  "author": {
    "name": "Paul Uithol",
    "email": "https://github.com/PaulUithol"
  },
  "contributors": "Listed at <https://github.com/PaulUithol/Backbone-relational/contributors>",
  "dependencies": {
    "underscore": ">=1.4.2",
    "backbone": ">=0.9.9"
  },
  "lib": ".",
  "main": "backbone-relational.js",
  "version": "0.7.0",
  "gitHead": "169e414904e1a92e342e0187abca1371b0ffac65",
  "readme": "# Backbone-relational\nBackbone-relational provides one-to-one, one-to-many and many-to-one relations between models for [Backbone](https://github.com/documentcloud/backbone). To use relations, extend `Backbone.RelationalModel` (instead of the regular `Backbone.Model`) and define a property `relations`, containing an array of option objects. Each relation must define (as a minimum) the `type`, `key` and `relatedModel`. Available relation types are `Backbone.HasOne` and `Backbone.HasMany`. Backbone-relational features:\n\n* Bidirectional relations, which notify related models of changes through events.\n* Control how relations are serialized using the `includeInJSON` option.\n* Automatically convert nested objects in a model's attributes into Model instances using the `createModels` option.\n* Lazily retrieve (a set of) related models through the `fetchRelated(key<string>, [options<object>], update<bool>)` method.\n* Determine the type of `HasMany` collections with `collectionType`.\n* Bind new events to a `Backbone.RelationalModel` for:\n\t* addition to a `HasMany` relation (bind to `add:<key>`; arguments: `(addedModel, relatedCollection)`),\n\t* removal from a `HasMany` relation (bind to `remove:<key>`; arguments: `(removedModel, relatedCollection)`),\n\t* reset of a `HasMany` relation (bind to `reset:<key>`; arguments: `(relatedCollection)`),\n\t* changes to the key itself on `HasMany` and `HasOne` relations (bind to `update:<key>`; arguments=`(model, relatedModel/relatedCollection)`).\n\n## Contents\n\n* [Getting started](#getting-started)\n* [Backbone.Relation options](#backbone-relation)\n* [Backbone.RelationalModel](#backbone-relationalmodel)\n* [Example](#example)\n* [Known problems and solutions](#q-and-a)\n* [Under the hood](#under-the-hood)\n\n\n## <a name=\"getting-started\"/>Getting started\n\nResources to get you started with Backbone-relational:\n\n* [A great tutorial by antoviaque](http://antoviaque.org/docs/tutorials/backbone-relational-tutorial/) ([and the accompanying git repository](https://github.com/antoviaque/backbone-relational-tutorial))\n\n\n### <a name=\"installation\"/>Installation\n\nBackbone-relational depends on [backbone](https://github.com/documentcloud/backbone) (and thus on  [underscore](https://github.com/documentcloud/underscore)). Include Backbone-relational right after Backbone and Underscore:\n\n```html\n<script type=\"text/javascript\" src=\"./js/underscore.js\"></script>\n<script type=\"text/javascript\" src=\"./js/backbone.js\"></script>\n<script type=\"text/javascript\" src=\"./js/backbone-relational.js\"></script>\n```\n\nBackbone-relational has been tested with Backbone 0.9.9 (or newer) and Underscore 1.4.2 (or newer).\n\n\n## <a name=\"backbone-relation\"/>Backbone.Relation options\n\nEach `Backbone.RelationalModel` can contain an array of `relations`.\nEach relation supports a number of options, of which `relatedModel`, `key` and `type` are mandatory.\nA relation could look like the following:\n\n```javascript\nZoo = Backbone.RelationalModel.extend({\n\trelations: [{\n\t\ttype: Backbone.HasMany,\n\t\tkey: 'animals',\n\t\trelatedModel: 'Animal',\n\t\tcollectionType: 'AnimalCollection',\n\t\treverseRelation: {\n\t\t\tkey: 'livesIn',\n\t\t\tincludeInJSON: 'id'\n\t\t\t// 'relatedModel' is automatically set to 'Zoo'; the 'relationType' to 'HasOne'.\n\t\t}\n\t}]\n});\n\nAnimal = Backbone.RelationalModel.extend({\n\turlRoot: '/animal/'\n});\n\nAnimalCollection = Backbone.Collection.extend({\n\tmodel: Animal,\n\t\n\turl: function( models ) {\n\t\treturn '/animal/' + ( models ? 'set/' + _.pluck( models, 'id' ).join(';') + '/' : '' );\n\t}\n});\n```\n\n### relatedModel\n\nValue: a string (which can be resolved to an object type on the global scope), or a reference to a `Backbone.RelationalModel` type.\n\n### key\n\nValue: a string. References an attribute name on `relatedModel`.\n\n### type\n\nValue: a string, or a reference to a `Backbone.Relation` type\n\nExample: `Backbone.HasOne` or `'HasMany'`.\n\n###### **HasOne relations (`Backbone.HasOne`)**\n\nThe key for a `HasOne` relation consists of a single `Backbone.RelationalModel`. The default `reverseRelation.type` for a HasOne relation is HasMany.\nThis can be set to `HasOne` instead, to create a one-to-one relation.\n\n###### **HasMany relations (`Backbone.HasMany`)**\n\nThe key for a `HasMany` relation consists of a `Backbone.Collection`, containing zero or more `Backbone.RelationalModel`s.\nThe default `reverseRelation.type` for a HasMany relation is HasOne; this is the only option here, since many-to-many is not supported directly.\n\n###### **<a name=\"many-to-many\"/>Many-to-many relations**\nA many-to-many relation can be modeled using two `Backbone.HasMany` relations, with a link model in between:\n\n```javascript\nPerson = Backbone.RelationalModel.extend({\n\trelations: [\n\t\t{\n\t\t\ttype: 'HasMany',\n\t\t\tkey: 'jobs',\n\t\t\trelatedModel: 'Job',\n\t\t\treverseRelation: {\n\t\t\t\tkey: 'person'\n\t\t\t}\n\t\t}\n\t]\n});\n\n// A link object between 'Person' and 'Company', to achieve many-to-many relations.\nJob = Backbone.RelationalModel.extend({\n\tdefaults: {\n\t\t'startDate': null,\n\t\t'endDate': null\n\t}\n})\n\nCompany = Backbone.RelationalModel.extend({\n\trelations: [\n\t\t{\n\t\t\ttype: 'HasMany',\n\t\t\tkey: 'employees',\n\t\t\trelatedModel: 'Job',\n\t\t\treverseRelation: {\n\t\t\t\tkey: 'company'\n\t\t\t}\n\t\t}\n\t]\n});\n\nniceCompany = new Company( { name: 'niceCompany' } );\nniceCompany.bind( 'add:employees', function( model, coll ) {\n\t\t// Will see a Job with attributes { person: paul, company: niceCompany } being added here\n\t});\n\npaul.get( 'jobs' ).add( { company: niceCompany } );\n```\n\n### keySource\n\nValue: a string. References an attribute on the data used to instantiate `relatedModel`.\n\nUsed to override `key` when determining what data to use when (de)serializing a relation, since the data backing your relations may use different naming conventions.\nFor example, a Rails backend may provide the keys suffixed with `_id` or `_ids`. The behavior for `keySource` corresponds to the following rules:\n\n1. When a relation is instantiated, the contents of the `keySource` are used as it's initial data.\n2. The application uses the regular `key` attribute to interface with the relation and the models in it; the `keySource` is not available as an attribute for the model.\n\nSo you may be provided with data containing `animal_ids`, while you want to access this relation as `zoo.get( 'animals' );`.\n\n**NOTE**: for backward compatibility reasons, setting `keySource` will set `keyDestination` as well. \nThis means that when saving `zoo`, the `animals` attribute will be serialized back into the `animal_ids` key.\n\n**WARNING**: when using a `keySource`, you should not use that attribute name for other purposes.\n\n### keyDestination\n\nValue: a string. References an attribute to serialize `relatedModel` into.\n\nUsed to override `key` (and `keySource`) when determining what attribute to be written into when serializing a relation, since the server backing your relations may use different naming conventions.\nFor example, a Rails backend may expect the keys to be suffixed with `_attributes` for nested attributes.\n\nWhen calling `toJSON` on a model (either via `Backbone.sync`, or directly), the data in the `key` attribute is transformed and assigned to the `keyDestination`.\n\nSo you may want a relation to be serialized into the `animals_attributes` key, while you want to access this relation as `zoo.get( 'animals' );`.\n\n**WARNING**: when using a `keyDestination`, you should not use that attribute name for other purposes.\n\n### collectionType\n\nValue: a string (which can be resolved to an object type on the global scope), or a reference to a `Backbone.Collection` type.\n\nDetermine the type of collections used for a `HasMany` relation. If you define a `url(models<Backbone.Model[]>)` function on\nthe specified collection, this enables `fetchRelated` to fetch all missing models in one request, instead of firing a separate request for each.\nSee [Backbone-tastypie](https://github.com/PaulUithol/backbone-tastypie/blob/master/backbone_tastypie/static/js/backbone-tastypie.js#L92) for an example\nof a `url` function that can build a url for the collection (or a subset of models).\n\n### collectionKey\n\nValue: a string or a boolean\n\nUsed to create a back reference from the `Backbone.Collection` used for a `HasMany` relation to the model on the other side of this relation.\nBy default, the relation's `key` attribute will be used to create a reference to the RelationalModel instance from the generated collection.\nIf you set `collectionKey` to a string, it will use that string as the reference to the RelationalModel, rather than the relation's `key` attribute.\nIf you don't want this behavior at all, set `collectionKey` to false (or any falsy value) and this reference will not be created.\n\n### collectionOptions\n\nValue: an options hash or a function that accepts an instance of a `Backbone.RelationalModel` and returns an option hash\n\nUsed to provide options for the initialization of the collection in the \"Many\"-end of a `HasMany` relation. Can be an options hash or\na function that should take the instance in the \"One\"-end of the \"HasMany\" relation and return an options hash\n\n### includeInJSON\n\nValue: a boolean, a string referencing one of the model's attributes, or an array of strings referencing model attributes. Default: `true`.\n\nDetermines how the contents of a relation will be serialized following a call to the `toJSON` method. If you specify a:\n\n* Boolean: a value of `true` serializes the full set of attributes on the related model(s).\n  Set to `false` to exclude the relation completely.\n* String: include a single attribute from the related model(s). For example, `'name'`,\n  or `Backbone.Model.prototype.idAttribute` to include ids.\n* String[]: includes the specified attributes from the related model(s).\n\nOnly specifying `true` is cascading, meaning the relations of the model will get serialized as well!\n\n### createModels\n\nValue: a boolean. Default: `true`.\n\nShould models be created from nested objects, or not?\n\n### reverseRelation\n\nIf the relation should be bidirectional, specify the details for the reverse relation here.\nIt's only mandatory to supply a `key`; `relatedModel` is automatically set. The default `type` for a `reverseRelation` is `HasMany` for a `HasOne` relation (which can be overridden to `HasOne` in order to create a one-to-one relation), and `HasOne` for a `HasMany` relation. In this case, you cannot create a reverseRelation with type `HasMany` as well; please see [Many-to-many relations](#many-to-many) on how to model these type of relations.\n\n**Please note**: if you define a relation (plus a `reverseRelation`) on a model, but never actually create an instance of that model, the model's `constructor` will never run, which means it's `initializeRelations` will never get called, and the reverseRelation will not be initialized either. In that case, you could either define the relation on the opposite model, or define two single relations. See [issue 20](https://github.com/PaulUithol/Backbone-relational/issues/20) for a discussion.\n\n## <a name=\"backbone-relationalmodel\"/>Backbone.RelationalModel\n\n`Backbone.RelationalModel` introduces a couple of new methods, events and properties.\n\n### Methods\n\n###### **getRelations `relationalModel.getRelations()`**\n\nReturns the set of initialized relations on the model.\n\n###### **fetchRelated `relationalModel.fetchRelated(key<string>, [options<object>], [update<boolean>])`**\n\nFetch models from the server that were referenced in the model's attributes, but have not been found/created yet.\nThis can be used specifically for lazy-loading scenarios.  Setting `update` to true guarantees that the model\nwill be fetched from the server and any model that already exists in the store will be updated with the retrieved data.\n\nBy default, a separate request will be fired for each additional model that is to be fetched from the server.\nHowever, if your server/API supports it, you can fetch the set of models in one request by specifying a `collectionType`\nfor the relation you call `fetchRelated` on. The `collectionType` should have an overridden `url(models<Backbone.Model[]>)`\nmethod that allows it to construct a url for an array of models.\nSee the example at the top of [Backbone.Relation options](#backbone-relation) or\n[Backbone-tastypie](https://github.com/PaulUithol/backbone-tastypie/blob/master/backbone_tastypie/static/js/backbone-tastypie.js#L92) for an example.\n\n### Methods on the type itself\n\nSeveral methods don't operate on model instances, but are defined on the type itself.\n\n###### **setup `ModelType.setup()`**\n\nInitialize the relations and submodels for the model type. See the [`Q and A`](#q-and-a) for a possible scenario where\nit's useful to call this method manually.\n\n###### **build `ModelType.build(attributes<object>, [options<object>])`**\n\nCreate an instance of a model, taking into account what submodels have been defined.\n\n###### **findOrCreate `ModelType.findOrCreate(attributes<string|number|object>, [options<object>])`**\n\nSearch for a model instance in the `Backbone.Relational.store`.\n\n* If `attributes` is a string or a number, `findOrCreate` will just query the `store` and return a model if found.\n* If `attributes` is an object, the model will be updated with `attributes` if found.\n  Otherwise, a new model is created with `attributes` (unless `options.create` is explicitly set to `false`).\n\n### Events\n\n* `add`: triggered on addition to a `HasMany` relation.  \n  Bind to `add:<key>`; arguments: `(addedModel<Backbone.Model>, related<Backbone.Collection>)`.\n* `remove`: triggered on removal from a `HasMany` relation.  \n  Bind to `remove:<key>`; arguments: `(removedModel<Backbone.Model>, related<Backbone.Collection>)`.\n* `update`: triggered on changes to the key itself on `HasMany` and `HasOne` relations.  \n  Bind to `update:<key>`; arguments: `(model<Backbone.Model>, related<Backbone.Model|Backbone.Collection>)`.\n\n\n### Properties\n\nProperties can be defined along with the subclass prototype when extending `Backbone.RelationalModel` or a subclass thereof.\n\n###### <a name=\"property-submodel-types\" />**subModelTypes**\n\nValue: an object. Default: `{}`.\n\nA mapping that defines what submodels exist for the model (the `superModel`) on which `subModelTypes` is defined.\nThe keys are used to match the [`subModelTypeAttribute`](#property-submodel-type-attribute) when deserializing,\nand the values determine what type of submodel should be created for a key. When building model instances from data,\nwe need to determine what kind of object we're dealing with in order to create instances of the right `subModel` type.\nThis is done by finding the model for which the key is equal to the value of the\n[`submodelTypeAttribute`](#property-submodel-type-attribute) attribute on the passed in data.\n\nEach `subModel` is considered to be a proper submodel of its superclass (the model type you're extending),\nwith a shared id pool. This means that when looking for an object of the supermodel's type, objects\nof a submodel's type can be returned as well, as long as the id matches. In effect, any relations pointing to\nthe supermodel will look for instances of it's submodels as well.\n\nExample:\n\n```javascript\nMammal = Animal.extend({\n\tsubModelTypes: {\n\t\t'primate': 'Primate',\n\t\t'carnivore': 'Carnivore'\n\t}\n});\nvar Primate = Mammal.extend();\nvar Carnivore = Mammal.extend();\n\nvar MammalCollection = AnimalCollection.extend({\n\tmodel: Mammal\n});\n\n// Create a collection that contains a 'Primate' and a 'Carnivore'.\nvar mammals = new MammalCollection([\n\t{ id: 3, species: 'chimp', type: 'primate' },\n\t{ id: 5, species: 'panther', type: 'carnivore' }\n]);\n```\n\nSuppose that we have an `Mammal` model and a `Primate` model extending `Mammal`. If we have a `Primate` object with\nid `3`, this object will be returned when we have a relation pointing to a `Mammal` with id `3`, as `Primate` is\nregarded a specific kind of `Mammal`; it's just a `Mammal` with possibly some primate-specific properties or methods.\n\nNote that this means that there cannot be any overlap in ids between instances of `Mammal` and `Primate`, as the\n`Primate` with id `3` will *be* the `Mammal` with id `3`.\n\n###### <a name=\"property-submodel-type-attribute\" />**subModelTypeAttribute**\n\nValue: a string. Default: `\"type\"`.\n\nThe `subModelTypeAttribute` is a references an attribute on the data used to instantiate `relatedModel`.\nThe attribute that will be checked to determine the type of model that\nshould be built when a raw object of attributes is set as the related value,\nand if the `relatedModel` has one or more submodels.\n\nSee [`subModelTypes`](#property-submodel-types) for more information.\n\n\n## <a name=\"example\"/>Example\n\n```javascript\npaul = new Person({\n\tid: 'person-1',\n\tname: 'Paul',\n\tuser: { id: 'user-1', login: 'dude', email: 'me@gmail.com' }\n});\n\n// A User object is automatically created from the JSON; so 'login' returns 'dude'.\npaul.get('user').get('login');\n\nourHouse = new House({\n\tid: 'house-1',\n\tlocation: 'in the middle of the street',\n\toccupants: ['person-1', 'person-2', 'person-5']\n});\n\n// 'ourHouse.occupants' is turned into a Backbone.Collection of Persons.\n// The first person in 'ourHouse.occupants' will point to 'paul'.\nourHouse.get('occupants').at(0); // === paul\n\n// If a collection is created from a HasMany relation, it contains a reference\n// back to the originator of the relation\nourHouse.get('occupants').livesIn; // === ourHouse\n\n// the relation from 'House.occupants' to 'Person' has been defined as a bi-directional HasMany relation,\n// with a reverse relation to 'Person.livesIn'. So, 'paul.livesIn' will automatically point back to 'ourHouse'.\npaul.get('livesIn'); // === ourHouse\n\n// You can control which relations get serialized to JSON (when saving), using the 'includeInJSON'\n// property on a Relation. Also, each object will only get serialized once to prevent loops.\npaul.get('user').toJSON();\n\t/* result:\n\t\t{\n\t\t\temail: \"me@gmail.com\",\n\t\t\tid: \"user-1\",\n\t\t\tlogin: \"dude\",\n\t\t\tperson: {\n\t\t\t\tid: \"person-1\",\n\t\t\t\tname: \"Paul\",\n\t\t\t\tlivesIn: {\n\t\t\t\t\tid: \"house-1\",\t\n\t\t\t\t\tlocation: \"in the middle of the street\",\n\t\t\t\t\toccupants: [\"person-1\"] // just the id, since 'includeInJSON' references the 'idAttribute'\n\t\t\t\t},\n\t\t\t\tuser: \"user-1\" // not serialized because it is already in the JSON, so we won't create a loop\n\t\t\t}\n\t\t}\n\t*/\n\n// Load occupants 'person-2' and 'person-5', which don't exist yet, from the server\nourHouse.fetchRelated( 'occupants' );\n\n// Use the 'add' and 'remove' events to listen for additions/removals on HasMany relations (like 'House.occupants').\nourHouse.bind( 'add:occupants', function( model, coll ) {\n\t\t// create a View?\n\t\tconsole.debug( 'add %o', model );\n\t});\nourHouse.bind( 'remove:occupants', function( model, coll ) {\n\t\t// destroy a View?\n\t\tconsole.debug( 'remove %o', model );\n\t});\n\n// Use the 'update' event to listen for changes on a HasOne relation (like 'Person.livesIn').\npaul.bind( 'update:livesIn', function( model, attr ) {\n\t\tconsole.debug( 'update to %o', attr );\n\t});\n\n\n// Modifying either side of a bi-directional relation updates the other side automatically.\n// Make paul homeless; triggers 'remove:occupants' on ourHouse, and 'update:livesIn' on paul\nourHouse.get('occupants').remove( paul.id ); \n\npaul.get('livesIn'); // yup; nothing.\n\n// Move back in; triggers 'add:occupants' on ourHouse, and 'update:livesIn' on paul\npaul.set( { 'livesIn': 'house-1' } );\n```\n\nThis is achieved using the following relations and models:\n\n```javascript\nHouse = Backbone.RelationalModel.extend({\n\t// The 'relations' property, on the House's prototype. Initialized separately for each instance of House.\n\t// Each relation must define (as a minimum) the 'type', 'key' and 'relatedModel'. Options are\n\t// 'includeInJSON', 'createModels' and 'reverseRelation', which takes the same options as the relation itself.\n\trelations: [\n\t\t{\n\t\t\ttype: Backbone.HasMany, // Use the type, or the string 'HasOne' or 'HasMany'.\n\t\t\tkey: 'occupants',\n\t\t\trelatedModel: 'Person',\n\t\t\tincludeInJSON: Backbone.Model.prototype.idAttribute,\n\t\t\tcollectionType: 'PersonCollection',\n\t\t\treverseRelation: {\n\t\t\t\tkey: 'livesIn'\n\t\t\t}\n\t\t}\n\t]\n});\n\nPerson = Backbone.RelationalModel.extend({\n\trelations: [\n\t\t{ // Create a (recursive) one-to-one relationship\n\t\t\ttype: Backbone.HasOne,\n\t\t\tkey: 'user',\n\t\t\trelatedModel: 'User',\n\t\t\treverseRelation: {\n\t\t\t\ttype: Backbone.HasOne,\n\t\t\t\tkey: 'person'\n\t\t\t}\n\t\t}\n\t],\n\t\n\tinitialize: function() {\n\t\t// do whatever you want :)\n\t}\n});\n\nPersonCollection = Backbone.Collection.extend({\n\turl: function( models ) {\n\t\t// Logic to create a url for the whole collection, or a set of models.\n\t\t// See the tests, or Backbone-tastypie, for an example.\n\t\treturn '/person/' + ( models ? 'set/' + _.pluck( models, 'id' ).join(';') + '/' : '' );\n\t}\n});\n\nUser = Backbone.RelationalModel.extend();\n```\n\n## <a name=\"q-and-a\"/>Known problems and solutions\n\n> **Q:** (Reverse) relations or submodels don't seem to be initialized properly (and I'm using CoffeeScript!)\n\n**A:** You're probably using the syntax `class MyModel extends Backbone.RelationalModel` instead of `MyModel = Backbone.RelationalModel.extend`.\nThis has advantages in CoffeeScript, but it also means that `Backbone.Model.extend` will not get called.\nInstead, CoffeeScript generates piece of code that would normally achieve roughly the same.\nHowever, `extend` is also the method that Backbone-relational overrides to set up relations and other things as you're defining your `Backbone.RelationalModel` subclass.\n\nFor exactly this scenario where you're not using `.extend`, `Backbone.RelationalModel` has the `.setup` method, that you can call manually after defining your subclass CoffeeScript-style. For example:\n\n```javascript\nclass MyModel extends Backbone.RelationalModel\n\trelations: [\n\t\t// etc\n\t]\n\nMyModel.setup()\n```\n\nSee [issue #91](https://github.com/PaulUithol/Backbone-relational/issues/91) for more information.\n\n> **Q:** After a fetch, I don't get `add:<key>` events for nested relations.\n\n**A:** This is due to `Backbone.Collection.reset` silencing add events. Pass `fetch( {add: true} )` to bypass this problem.\nYou may want to override `Backbone.Collection.fetch` for this, and also trigger an event when the fetch has finished while you're at it.\nExample:\n\n```javascript\nvar _fetch = Backbone.Collection.prototype.fetch;\nBackbone.Collection.prototype.fetch = function( options ) {\n\toptions || ( options = {} );\n\t_.defaults( options, { add: true } );\n\n\t// Remove old models\n\tthis.reset();\n\t\n\t// Call 'fetch', and trigger an event when done.\n\tvar dit = this,\n\t\trequest = _fetch.call( this, options );\n\trequest.done( function() {\n\t\t\tif ( !options.silent ) {\n\t\t\t\tdit.trigger( 'fetch', dit, options );\n\t\t\t}\n\t\t});\n\n\treturn request;\n};\n```\n\n## <a name=\"under-the-hood\"/>Under the hood\n\nEach `Backbone.RelationalModel` registers itself with `Backbone.Store` upon creation (and is removed from the `Store` when destroyed).\nWhen creating or updating an attribute that is a key in a relation, removed related objects are notified of their removal,\nand new related objects are looked up in the `Store`.\n",
  "readmeFilename": "README.md",
  "_id": "backbone-rel@0.7.0"
}